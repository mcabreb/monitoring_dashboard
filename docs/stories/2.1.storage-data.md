# Story 2.1: Storage Data Collection

## Status

Approved

## Story

**As a** developer,
**I want** a data collection module that gathers disk and mount point information,
**so that** the Storage panel can display real storage data.

## Acceptance Criteria

1. `data_sources/storage.py` module exists with functions to collect storage metrics
2. Disk partitions are enumerated using `psutil.disk_partitions()` filtering relevant mount points
3. Disk usage (total, used, free, percent) is collected for each partition using `psutil.disk_usage()`
4. Module returns a list of disk objects with mount point, device, filesystem type, and usage stats
5. Module includes unit tests verifying data collection returns expected structure
6. Collection handles unmounted/inaccessible partitions gracefully (skip with warning, don't crash)

## Tasks / Subtasks

- [ ] Create DiskInfo data model (AC: 4)
  - [ ] Create src/monitor_dashboard/models/metrics.py (extend if exists)
  - [ ] Define DiskInfo dataclass with all fields
  - [ ] Use @dataclass(frozen=True) for immutability
- [ ] Create StorageCollector class (AC: 1, 2, 3, 4)
  - [ ] Create src/monitor_dashboard/data_sources/storage.py
  - [ ] Implement collect() -> list[DiskInfo] method
  - [ ] Use psutil.disk_partitions(all=False) to get physical partitions
  - [ ] Filter out pseudo filesystems (proc, sys, dev, run, snap)
  - [ ] Call psutil.disk_usage(mount_point) for each partition
  - [ ] Return list of DiskInfo objects sorted by mount point
- [ ] Handle inaccessible partitions (AC: 6)
  - [ ] Wrap disk_usage() in try/except for each partition
  - [ ] Log warning for inaccessible partitions
  - [ ] Skip partition and continue with others
  - [ ] Return empty list if all partitions fail (don't crash)
- [ ] Write unit tests (AC: 5)
  - [ ] Create tests/unit/data_sources/test_storage.py
  - [ ] Test DiskInfo dataclass fields
  - [ ] Test collect() returns list of DiskInfo
  - [ ] Test filtering of pseudo filesystems
  - [ ] Test graceful handling of inaccessible partition
  - [ ] Mock psutil for deterministic testing

## Dev Notes

**DiskInfo Data Model:**
```python
from dataclasses import dataclass

@dataclass(frozen=True)
class DiskInfo:
    """Information about a mounted disk partition."""
    mount_point: str    # e.g., "/", "/home"
    device: str         # e.g., "/dev/sda1"
    fs_type: str        # e.g., "ext4", "btrfs"
    total: int          # Total bytes
    used: int           # Used bytes
    free: int           # Free bytes
    percent: float      # Usage percentage (0-100)
```

**StorageCollector Pattern:**
```python
import psutil
import logging

logger = logging.getLogger(__name__)

# Pseudo filesystems to filter out
PSEUDO_FS_TYPES = frozenset({
    'proc', 'sysfs', 'devfs', 'devtmpfs', 'tmpfs',
    'squashfs', 'overlay', 'aufs', 'none'
})

PSEUDO_MOUNT_PREFIXES = ('/proc', '/sys', '/dev', '/run', '/snap')

class StorageCollector:
    """Collects disk partition and usage information."""

    def collect(self) -> list[DiskInfo]:
        """Gather disk usage for all mounted partitions.

        Returns:
            List of DiskInfo objects, sorted by mount point.
            Returns empty list if all partitions fail.
        """
        disks = []

        try:
            partitions = psutil.disk_partitions(all=False)
        except Exception as e:
            logger.error(f"Failed to enumerate partitions: {e}")
            return []

        for part in partitions:
            # Filter pseudo filesystems
            if part.fstype in PSEUDO_FS_TYPES:
                continue
            if any(part.mountpoint.startswith(p) for p in PSEUDO_MOUNT_PREFIXES):
                continue

            try:
                usage = psutil.disk_usage(part.mountpoint)
                disks.append(DiskInfo(
                    mount_point=part.mountpoint,
                    device=part.device,
                    fs_type=part.fstype,
                    total=usage.total,
                    used=usage.used,
                    free=usage.free,
                    percent=usage.percent,
                ))
            except (PermissionError, OSError) as e:
                logger.warning(f"Cannot access {part.mountpoint}: {e}")
                continue

        return sorted(disks, key=lambda d: d.mount_point)
```

**psutil Notes:**
- `disk_partitions(all=False)` returns physical devices only
- `disk_partitions(all=True)` includes pseudo filesystems
- `disk_usage(path)` returns sdiskusage(total, used, free, percent)
- May raise PermissionError or OSError for inaccessible mounts

**Typical Linux Mount Points:**
- `/` - root filesystem
- `/home` - user home directories
- `/boot` - boot partition
- `/var` - variable data

### Testing

**Test Location:** tests/unit/data_sources/

**Testing Standards:**
- Framework: pytest 8.0.0
- Mocking: pytest-mock
- Run with: `pytest tests/unit/data_sources/test_storage.py`

**Test Patterns:**
```python
from unittest.mock import MagicMock

def test_collect_returns_disk_info_list(mocker):
    """Test that collect() returns list of DiskInfo."""
    mock_partition = MagicMock(
        device='/dev/sda1',
        mountpoint='/',
        fstype='ext4'
    )
    mock_usage = MagicMock(
        total=500_000_000_000,
        used=200_000_000_000,
        free=300_000_000_000,
        percent=40.0
    )
    mocker.patch('psutil.disk_partitions', return_value=[mock_partition])
    mocker.patch('psutil.disk_usage', return_value=mock_usage)

    collector = StorageCollector()
    disks = collector.collect()

    assert len(disks) == 1
    assert disks[0].mount_point == '/'
    assert disks[0].percent == 40.0

def test_collect_filters_pseudo_filesystems(mocker):
    """Test that pseudo filesystems are filtered out."""
    partitions = [
        MagicMock(device='/dev/sda1', mountpoint='/', fstype='ext4'),
        MagicMock(device='tmpfs', mountpoint='/dev/shm', fstype='tmpfs'),
        MagicMock(device='proc', mountpoint='/proc', fstype='proc'),
    ]
    mocker.patch('psutil.disk_partitions', return_value=partitions)
    mocker.patch('psutil.disk_usage', return_value=MagicMock(
        total=100, used=50, free=50, percent=50.0
    ))

    collector = StorageCollector()
    disks = collector.collect()

    assert len(disks) == 1
    assert disks[0].mount_point == '/'

def test_collect_handles_inaccessible_partition(mocker):
    """Test graceful handling of inaccessible partitions."""
    partitions = [
        MagicMock(device='/dev/sda1', mountpoint='/', fstype='ext4'),
        MagicMock(device='/dev/sdb1', mountpoint='/mnt/external', fstype='ext4'),
    ]
    mocker.patch('psutil.disk_partitions', return_value=partitions)

    def mock_usage(path):
        if path == '/mnt/external':
            raise PermissionError("Access denied")
        return MagicMock(total=100, used=50, free=50, percent=50.0)

    mocker.patch('psutil.disk_usage', side_effect=mock_usage)

    collector = StorageCollector()
    disks = collector.collect()

    # Should return only accessible partition
    assert len(disks) == 1
    assert disks[0].mount_point == '/'
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_To be filled by QA agent_
