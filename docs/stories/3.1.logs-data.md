# Story 3.1: System Logs Data Collection

## Status

Draft

## Story

**As a** developer,
**I want** a data collection module that retrieves dmesg output,
**so that** the Logs panel can display system log entries.

## Acceptance Criteria

1. `data_sources/logs.py` module exists with functions to collect log data
2. Module retrieves dmesg output via subprocess call (`dmesg --time-format iso`)
3. Each log entry is parsed into: timestamp, severity level, message
4. Severity detection identifies: emergency, alert, critical, error, warning, notice, info, debug
5. Module returns the last 100 entries (configurable buffer size)
6. Module handles dmesg permission issues gracefully (may require running with appropriate permissions)
7. Module includes unit tests with sample dmesg output

## Tasks / Subtasks

- [ ] Create LogEntry and LogSeverity data models (AC: 3, 4)
  - [ ] Create src/monitor_dashboard/models/logs.py
  - [ ] Define LogSeverity enum with all severity levels
  - [ ] Define LogEntry dataclass with all fields
  - [ ] Use @dataclass(frozen=True) for immutability
- [ ] Create LogsCollector class (AC: 1, 2, 5)
  - [ ] Create src/monitor_dashboard/data_sources/logs.py
  - [ ] Implement collect(limit: int = 100) -> list[LogEntry] method
  - [ ] Call dmesg subprocess with appropriate flags
  - [ ] Parse each line into LogEntry
  - [ ] Return last `limit` entries
- [ ] Implement dmesg parsing (AC: 2, 3, 4)
  - [ ] Use `dmesg --time-format iso` for parseable timestamps
  - [ ] Parse ISO timestamp from each line
  - [ ] Extract severity from kernel format (if available)
  - [ ] Use regex or string parsing for message extraction
  - [ ] Handle malformed lines gracefully
- [ ] Implement severity detection (AC: 4)
  - [ ] Parse kernel severity level if present in output
  - [ ] Common patterns: `<3>` = error, `<4>` = warning, etc.
  - [ ] Also detect from message content (heuristics)
  - [ ] Default to INFO if severity cannot be determined
- [ ] Handle permission issues (AC: 6)
  - [ ] Catch PermissionError from subprocess
  - [ ] Return informative error message or empty list
  - [ ] Log warning with instructions for user
  - [ ] Document requirement: add user to `adm` group
- [ ] Write unit tests (AC: 7)
  - [ ] Create tests/unit/data_sources/test_logs.py
  - [ ] Test LogEntry dataclass
  - [ ] Test parsing of various dmesg formats
  - [ ] Test severity detection
  - [ ] Test handling of permission errors
  - [ ] Use sample dmesg output as test data

## Dev Notes

**Data Models:**
```python
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

class LogSeverity(Enum):
    EMERGENCY = "emerg"     # System is unusable
    ALERT = "alert"         # Action must be taken immediately
    CRITICAL = "crit"       # Critical conditions
    ERROR = "err"           # Error conditions
    WARNING = "warn"        # Warning conditions
    NOTICE = "notice"       # Normal but significant
    INFO = "info"           # Informational
    DEBUG = "debug"         # Debug-level messages

@dataclass(frozen=True)
class LogEntry:
    """Parsed dmesg log entry."""
    timestamp: datetime
    severity: LogSeverity
    message: str
    raw: str  # Original unparsed line
```

**LogsCollector Pattern:**
```python
import subprocess
import logging
from datetime import datetime
import re

logger = logging.getLogger(__name__)

# Kernel log levels (used in some dmesg output)
KERN_LEVELS = {
    0: LogSeverity.EMERGENCY,
    1: LogSeverity.ALERT,
    2: LogSeverity.CRITICAL,
    3: LogSeverity.ERROR,
    4: LogSeverity.WARNING,
    5: LogSeverity.NOTICE,
    6: LogSeverity.INFO,
    7: LogSeverity.DEBUG,
}

# Pattern for dmesg --time-format iso output
# Example: 2026-01-17T10:30:45,123456+00:00 [drm] message here
ISO_PATTERN = re.compile(
    r'^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}),?\d*[+-]\d{2}:\d{2}\s+(.*)$'
)

class LogsCollector:
    """Collects and parses dmesg log entries."""

    def collect(self, limit: int = 100) -> list[LogEntry]:
        """Retrieve recent dmesg entries.

        Args:
            limit: Maximum number of entries to return.

        Returns:
            List of LogEntry objects, most recent last.
        """
        try:
            result = subprocess.run(
                ['dmesg', '--time-format', 'iso'],
                capture_output=True,
                text=True,
                timeout=5.0,
            )

            if result.returncode != 0:
                logger.warning(f"dmesg returned {result.returncode}: {result.stderr}")
                return []

            entries = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    entry = self._parse_line(line)
                    if entry:
                        entries.append(entry)

            return entries[-limit:]

        except PermissionError:
            logger.warning(
                "Permission denied for dmesg. "
                "Add user to 'adm' group: sudo usermod -aG adm $USER"
            )
            return []
        except subprocess.TimeoutExpired:
            logger.warning("dmesg command timed out")
            return []
        except Exception as e:
            logger.error(f"Failed to collect logs: {e}")
            return []

    def _parse_line(self, line: str) -> LogEntry | None:
        """Parse a single dmesg line into LogEntry."""
        match = ISO_PATTERN.match(line)
        if not match:
            # Fallback: treat whole line as message
            return LogEntry(
                timestamp=datetime.now(),
                severity=LogSeverity.INFO,
                message=line,
                raw=line,
            )

        timestamp_str, message = match.groups()
        try:
            timestamp = datetime.fromisoformat(timestamp_str)
        except ValueError:
            timestamp = datetime.now()

        severity = self._detect_severity(message)

        return LogEntry(
            timestamp=timestamp,
            severity=severity,
            message=message,
            raw=line,
        )

    def _detect_severity(self, message: str) -> LogSeverity:
        """Detect severity from message content."""
        msg_lower = message.lower()

        if any(kw in msg_lower for kw in ['error', 'failed', 'failure', 'fault']):
            return LogSeverity.ERROR
        if any(kw in msg_lower for kw in ['warning', 'warn']):
            return LogSeverity.WARNING
        if any(kw in msg_lower for kw in ['critical', 'crit']):
            return LogSeverity.CRITICAL

        return LogSeverity.INFO
```

**dmesg Flags:**
- `--time-format iso` - ISO 8601 timestamps
- `--color=never` - Disable color codes (optional)
- `-T` - Human-readable timestamps (alternative)

**Permission Requirements:**
```bash
# Option 1: Add user to adm group (recommended)
sudo usermod -aG adm $USER
# Then log out and back in

# Option 2: Set kernel.dmesg_restrict
echo 'kernel.dmesg_restrict = 0' | sudo tee /etc/sysctl.d/10-dmesg.conf
sudo sysctl -p /etc/sysctl.d/10-dmesg.conf
```

### Testing

**Test Location:** tests/unit/data_sources/

**Testing Standards:**
- Framework: pytest 8.0.0
- Mocking: pytest-mock
- Run with: `pytest tests/unit/data_sources/test_logs.py`

**Sample Test Data:**
```python
SAMPLE_DMESG = """
2026-01-17T10:30:45,123456+00:00 [drm] GPU reset started
2026-01-17T10:30:46,234567+00:00 usb 1-1: USB disconnect
2026-01-17T10:30:47,345678+00:00 EXT4-fs error (device sda1): checksum failed
2026-01-17T10:30:48,456789+00:00 warning: CPU temperature above threshold
"""

def test_collect_returns_log_entries(mocker):
    """Test successful dmesg collection."""
    mocker.patch('subprocess.run', return_value=MagicMock(
        returncode=0,
        stdout=SAMPLE_DMESG,
        stderr=""
    ))

    collector = LogsCollector()
    entries = collector.collect()

    assert len(entries) == 4
    assert entries[0].message.startswith("[drm]")

def test_parse_detects_error_severity():
    """Test severity detection for error messages."""
    collector = LogsCollector()
    entry = collector._parse_line(
        "2026-01-17T10:30:47,345678+00:00 EXT4-fs error: checksum failed"
    )

    assert entry.severity == LogSeverity.ERROR

def test_collect_handles_permission_denied(mocker):
    """Test graceful handling of permission errors."""
    mocker.patch('subprocess.run', side_effect=PermissionError("denied"))

    collector = LogsCollector()
    entries = collector.collect()

    assert entries == []
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_To be filled by QA agent_
