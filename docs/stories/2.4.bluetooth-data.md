# Story 2.4: Bluetooth Device Data Collection

## Status

Approved

## Story

**As a** developer,
**I want** to retrieve connected Bluetooth devices and their battery levels,
**so that** the Devices panel can display Bluetooth device status.

## Acceptance Criteria

1. Connected Bluetooth devices are enumerated via UPower D-Bus interface
2. For each device: name, type (headphones, mouse, keyboard, etc.), battery percentage if available
3. Module detects device connection/disconnection events (for notification in Epic 3)
4. Module handles systems without Bluetooth gracefully (returns empty list, doesn't crash)
5. Module handles devices without battery reporting (show device, indicate "N/A" for battery)
6. Collection refreshes at 1Hz without blocking the UI

## Tasks / Subtasks

- [ ] Create BluetoothDevice and DeviceType data models (AC: 2)
  - [ ] Update src/monitor_dashboard/models/devices.py
  - [ ] Define DeviceType enum: HEADPHONES, MOUSE, KEYBOARD, GAMEPAD, OTHER
  - [ ] Define BluetoothDevice dataclass
  - [ ] Use @dataclass(frozen=True) for immutability
- [ ] Implement Bluetooth device enumeration (AC: 1, 2)
  - [ ] Update src/monitor_dashboard/data_sources/devices.py
  - [ ] Add collect_bluetooth() -> list[BluetoothDevice] method
  - [ ] Query UPower for devices with type "battery" in path
  - [ ] Parse device properties: name, type, battery percentage
  - [ ] Infer device type from UPower device type or name heuristics
- [ ] Track device connections/disconnections (AC: 3)
  - [ ] Maintain set of known connected device addresses
  - [ ] Compare current devices to previous devices
  - [ ] Add get_disconnected_devices() -> list[str] method
  - [ ] Return names of devices that disconnected since last call
  - [ ] Clear disconnection list after retrieval
- [ ] Handle no-Bluetooth systems (AC: 4)
  - [ ] Return empty list if no Bluetooth adapter
  - [ ] Do not log error (normal for some systems)
- [ ] Handle devices without battery (AC: 5)
  - [ ] Set battery_percent to None for devices without battery info
  - [ ] Include device in list regardless of battery availability
- [ ] Ensure non-blocking collection (AC: 6)
  - [ ] D-Bus calls should complete within timeout
  - [ ] Use cached values if D-Bus is slow
  - [ ] Collection should not block UI thread

## Dev Notes

**Data Models:**
```python
from dataclasses import dataclass
from enum import Enum

class DeviceType(Enum):
    HEADPHONES = "headphones"
    MOUSE = "mouse"
    KEYBOARD = "keyboard"
    GAMEPAD = "gamepad"
    OTHER = "other"

@dataclass(frozen=True)
class BluetoothDevice:
    """Connected Bluetooth device with optional battery info."""
    name: str                       # Display name
    address: str                    # Bluetooth MAC address
    device_type: DeviceType
    battery_percent: int | None     # None if battery info unavailable
    is_connected: bool
```

**UPower Bluetooth Device Discovery:**
```python
# UPower device types
UPOWER_DEVICE_TYPES = {
    1: DeviceType.OTHER,      # Line power
    2: DeviceType.OTHER,      # Battery (laptop)
    5: DeviceType.MOUSE,
    6: DeviceType.KEYBOARD,
    7: DeviceType.OTHER,      # Pda
    8: DeviceType.OTHER,      # Phone
    # Add mappings for headphones, gamepad based on name heuristics
}

def collect_bluetooth(self) -> list[BluetoothDevice]:
    """Enumerate connected Bluetooth devices with battery status."""
    devices = []
    try:
        upower = self._get_bus().get(UPOWER_BUS, UPOWER_PATH)
        device_paths = upower.EnumerateDevices()

        for path in device_paths:
            # Skip laptop battery (DisplayDevice)
            if "DisplayDevice" in path or "battery_" in path:
                continue

            # Look for Bluetooth devices (usually in path)
            if "bluetooth" not in path.lower() and "hid" not in path.lower():
                continue

            try:
                dev = self._get_bus().get(UPOWER_BUS, path)
                device = BluetoothDevice(
                    name=dev.Model or dev.NativePath or "Unknown Device",
                    address=self._extract_address(path),
                    device_type=self._infer_type(dev),
                    battery_percent=int(dev.Percentage) if dev.IsPresent else None,
                    is_connected=dev.IsPresent,
                )
                devices.append(device)
            except Exception as e:
                logger.debug(f"Skipping device {path}: {e}")

    except GLib.Error as e:
        logger.warning(f"Bluetooth enumeration failed: {e}")

    return devices
```

**Device Type Heuristics:**
```python
def _infer_type(self, device) -> DeviceType:
    """Infer device type from UPower info or name."""
    # Check UPower Type property
    upower_type = getattr(device, 'Type', 0)
    if upower_type in UPOWER_DEVICE_TYPES:
        return UPOWER_DEVICE_TYPES[upower_type]

    # Name-based heuristics
    name = (device.Model or device.NativePath or "").lower()
    if any(kw in name for kw in ['headphone', 'airpod', 'buds', 'earphone']):
        return DeviceType.HEADPHONES
    if any(kw in name for kw in ['mouse', 'mx ']):
        return DeviceType.MOUSE
    if any(kw in name for kw in ['keyboard', 'keychron']):
        return DeviceType.KEYBOARD
    if any(kw in name for kw in ['controller', 'gamepad', 'xbox', 'playstation']):
        return DeviceType.GAMEPAD

    return DeviceType.OTHER
```

**Disconnection Tracking:**
```python
def __init__(self):
    self._known_devices: set[str] = set()  # Set of addresses
    self._disconnected: list[str] = []      # Names of disconnected devices

def collect_bluetooth(self) -> list[BluetoothDevice]:
    devices = self._enumerate_devices()

    current_addresses = {d.address for d in devices}
    current_names = {d.address: d.name for d in devices}

    # Find disconnected devices
    disconnected = self._known_devices - current_addresses
    for addr in disconnected:
        # We need to store name -> address mapping for this
        self._disconnected.append(f"Device {addr}")

    self._known_devices = current_addresses
    return devices

def get_disconnected_devices(self) -> list[str]:
    """Get and clear list of recently disconnected device names."""
    result = self._disconnected.copy()
    self._disconnected.clear()
    return result
```

### Testing

**Test Location:** tests/unit/data_sources/

**Testing Standards:**
- Framework: pytest 8.0.0
- Mocking: pytest-mock
- Run with: `pytest tests/unit/data_sources/test_devices.py`

**Test Patterns:**
```python
def test_collect_bluetooth_returns_devices(mocker):
    """Test Bluetooth device enumeration."""
    mock_upower = MagicMock()
    mock_upower.EnumerateDevices.return_value = [
        '/org/freedesktop/UPower/devices/bluetooth_mouse'
    ]

    mock_device = MagicMock()
    mock_device.Model = "Logitech MX Master"
    mock_device.Percentage = 85.0
    mock_device.IsPresent = True
    mock_device.Type = 5  # Mouse

    mock_bus = MagicMock()
    mock_bus.get.side_effect = lambda b, p: mock_upower if p == UPOWER_PATH else mock_device
    mocker.patch('pydbus.SystemBus', return_value=mock_bus)

    collector = DevicesCollector()
    devices = collector.collect_bluetooth()

    assert len(devices) == 1
    assert devices[0].name == "Logitech MX Master"
    assert devices[0].battery_percent == 85

def test_collect_bluetooth_no_adapter(mocker):
    """Test handling when no Bluetooth adapter exists."""
    mock_bus = MagicMock()
    mock_bus.get.side_effect = GLib.Error("No adapter")
    mocker.patch('pydbus.SystemBus', return_value=mock_bus)

    collector = DevicesCollector()
    devices = collector.collect_bluetooth()

    assert devices == []

def test_disconnection_tracking():
    """Test that device disconnections are tracked."""
    collector = DevicesCollector()
    # First call - device present
    # Second call - device missing
    # get_disconnected_devices() should return device name
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_To be filled by QA agent_
