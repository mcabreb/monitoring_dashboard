# Story 3.7: Visual Alert Display

## Status

Ready for Review

Approved

## Story

**As a** user,
**I want** flashing visual alerts when critical thresholds are exceeded,
**so that** problems catch my attention even during passive monitoring.

## Acceptance Criteria

1. Active alerts trigger flashing effect on affected panel's LED indicator (1-2 Hz blink)
2. Alert notification appears in a dedicated area or overlay showing alert message
3. Multiple simultaneous alerts are all displayed (not just the first one)
4. Flashing continues until alert is acknowledged
5. Pressing 'a' acknowledges and dismisses all active alerts
6. Pressing 'A' acknowledges alerts one by one (cycles through)
7. Acknowledged alerts don't re-trigger immediately (cooldown period or hysteresis)

## Tasks / Subtasks

- [x] Implement LED flashing animation (AC: 1, 4)
  - [ ] Update LEDIndicator widget to support flashing
  - [ ] Add is_flashing property/method
  - [ ] Flash rate: 1-2 Hz (500-1000ms toggle)
  - [ ] Use textual timer for animation
  - [ ] Stop flashing when acknowledged
- [x] Create alert notification area (AC: 2, 3)
  - [ ] Create alert display widget/area in dashboard
  - [ ] Position: bottom of screen above info bar, or top
  - [ ] Display all active alert messages
  - [ ] Style with attention-grabbing colors (red background or border)
- [x] Display multiple alerts (AC: 3)
  - [ ] List all active alerts, not just first
  - [ ] Scrollable if many alerts (unlikely but handle)
  - [ ] Show alert type icon and message
- [x] Implement 'a' key binding (AC: 5)
  - [ ] Add binding to MonitorDashboardApp
  - [ ] Call alert_engine.acknowledge_all()
  - [ ] Update UI to reflect acknowledged state
  - [ ] Stop all flashing
  - [ ] Hide alert notification area
- [x] Implement 'A' key binding (AC: 6)
  - [ ] Add binding to MonitorDashboardApp
  - [ ] Call alert_engine.acknowledge_next()
  - [ ] Acknowledge oldest alert
  - [ ] Update UI - remove acknowledged alert from display
  - [ ] Continue flashing for remaining alerts
- [x] Integrate with alert engine (AC: 7)
  - [ ] Call alert_engine.check_thresholds() in refresh loop
  - [ ] Update panel LEDs based on alerts
  - [ ] Update notification area
  - [ ] Respect cooldown from engine
- [x] Connect LED flashing to specific panels (AC: 1)
  - [ ] Alert.source_panel identifies which panel to flash
  - [ ] LOW_BATTERY -> Devices panel
  - [ ] HIGH_CPU, LOW_MEMORY -> System Health panel
  - [ ] LOW_DISK -> Storage panel

## Dev Notes

**LED Flashing Implementation:**
```python
class LEDIndicator(Static):
    """LED status indicator with optional flashing."""

    def __init__(self):
        super().__init__()
        self._status = LEDStatus.OK
        self._is_flashing = False
        self._flash_visible = True
        self._flash_timer = None

    @property
    def status(self) -> LEDStatus:
        return self._status

    @status.setter
    def status(self, value: LEDStatus) -> None:
        self._status = value
        self._update_display()

    def start_flashing(self) -> None:
        """Start flashing the LED."""
        if not self._is_flashing:
            self._is_flashing = True
            self._flash_timer = self.set_interval(0.5, self._toggle_flash)

    def stop_flashing(self) -> None:
        """Stop flashing the LED."""
        self._is_flashing = False
        self._flash_visible = True
        if self._flash_timer:
            self._flash_timer.stop()
            self._flash_timer = None
        self._update_display()

    def _toggle_flash(self) -> None:
        """Toggle flash visibility."""
        self._flash_visible = not self._flash_visible
        self._update_display()

    def _update_display(self) -> None:
        """Update the LED display."""
        if self._is_flashing and not self._flash_visible:
            self.update("○")  # Empty circle when flashing off
        else:
            symbol = {
                LEDStatus.OK: "●",
                LEDStatus.WARNING: "●",
                LEDStatus.CRITICAL: "●",
            }[self._status]
            self.update(symbol)
```

**Alert Notification Area:**
```
┌─ ALERTS ──────────────────────────────────────────┐
│ ⚠️ Battery low: 15%                                │
│ ⚠️ CPU high: 92%                                   │
│ Press 'a' to dismiss all, 'A' to dismiss one     │
└───────────────────────────────────────────────────┘
```

**Alert Display Widget:**
```python
class AlertDisplay(Static):
    """Widget showing active alerts."""

    def __init__(self):
        super().__init__()
        self._alerts: list[Alert] = []

    def update_alerts(self, alerts: list[Alert]) -> None:
        """Update displayed alerts."""
        self._alerts = alerts
        if alerts:
            self.display = True
            lines = [f"⚠️ {a.message}" for a in alerts]
            lines.append("Press 'a' to dismiss all, 'A' to dismiss one")
            self.update("\n".join(lines))
        else:
            self.display = False

# CSS:
AlertDisplay {
    dock: bottom;
    height: auto;
    max-height: 5;
    background: $error;
    color: white;
    padding: 0 1;
    margin-bottom: 1;  # Above info bar
}

AlertDisplay:hidden {
    display: none;
}
```

**App Integration:**
```python
class MonitorDashboardApp(App):
    BINDINGS = [
        # ... existing bindings
        Binding("a", "acknowledge_all", "Dismiss All Alerts"),
        Binding("A", "acknowledge_one", "Dismiss One Alert"),
    ]

    def __init__(self):
        super().__init__()
        self._alert_engine = AlertEngine()

    def _refresh_data(self) -> None:
        # ... collect metrics ...

        # Check thresholds
        alerts = self._alert_engine.check_thresholds(
            metrics, battery, disks
        )

        # Update alert display
        alert_display = self.query_one(AlertDisplay)
        alert_display.update_alerts(alerts)

        # Update panel LEDs
        self._update_panel_leds(alerts)

    def _update_panel_leds(self, alerts: list[Alert]) -> None:
        """Update panel LEDs based on alerts."""
        # Group alerts by source panel
        panel_alerts = {}
        for alert in alerts:
            panel_alerts.setdefault(alert.source_panel, []).append(alert)

        # Update each panel
        for panel in self.query("BasePanel"):
            led = panel.query_one(LEDIndicator)
            if panel.id in panel_alerts:
                led.status = LEDStatus.CRITICAL
                led.start_flashing()
            else:
                led.stop_flashing()
                # LED status is set by panel's own logic

    def action_acknowledge_all(self) -> None:
        """Acknowledge all active alerts."""
        self._alert_engine.acknowledge_all()
        # Stop all flashing
        for led in self.query(LEDIndicator):
            led.stop_flashing()
        # Clear alert display
        self.query_one(AlertDisplay).update_alerts([])

    def action_acknowledge_one(self) -> None:
        """Acknowledge oldest alert."""
        alert = self._alert_engine.acknowledge_next()
        if alert:
            # Update display
            remaining = self._alert_engine.get_active_alerts()
            self.query_one(AlertDisplay).update_alerts(remaining)
            # Update LED for that panel if no more alerts
            if not any(a.source_panel == alert.source_panel for a in remaining):
                panel = self.query_one(f"#{alert.source_panel}")
                if panel:
                    panel.query_one(LEDIndicator).stop_flashing()
```

### Testing

**Test Location:** tests/integration/

**Testing Standards:**
- Framework: pytest with textual pilot API
- Run with: `pytest tests/integration/test_app.py`

**Test Cases:**
```python
async def test_alert_triggers_led_flashing():
    async with app.run_test() as pilot:
        # Trigger low battery alert
        app._alert_engine._alerts[AlertType.LOW_BATTERY] = Alert(...)

        app._refresh_data()

        devices_panel = app.query_one("#devices")
        led = devices_panel.query_one(LEDIndicator)
        assert led._is_flashing

async def test_a_key_acknowledges_all():
    async with app.run_test() as pilot:
        # Set up multiple alerts
        app._alert_engine._alerts = {...}

        await pilot.press("a")

        assert len(app._alert_engine.get_active_alerts()) == 0
        alert_display = app.query_one(AlertDisplay)
        assert alert_display.display is False

async def test_A_key_acknowledges_one():
    async with app.run_test() as pilot:
        # Set up 2 alerts
        # ...

        await pilot.press("A")

        assert len(app._alert_engine.get_active_alerts()) == 1

async def test_alert_notification_shows_all_alerts():
    async with app.run_test() as pilot:
        # Trigger multiple alerts
        # ...

        alert_display = app.query_one(AlertDisplay)
        content = str(alert_display.render())

        assert "Battery" in content
        assert "CPU" in content
```

**Manual Verification:**
- Trigger low battery (if possible) or modify threshold temporarily
- Observe LED flashing on affected panel
- Observe alert notification area
- Press 'a' and verify all alerts dismissed
- Press 'A' and verify one alert dismissed
- Verify cooldown prevents immediate re-trigger

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_To be filled by QA agent_
