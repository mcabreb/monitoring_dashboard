# Story 3.8: Bluetooth Disconnect Notification

## Status

Ready for Review

Approved

## Story

**As a** user,
**I want** to be notified when a Bluetooth device disconnects,
**so that** I'm aware if my headphones or other devices lose connection.

## Acceptance Criteria

1. When a previously connected Bluetooth device disconnects, an alert is triggered
2. Alert message identifies the device (e.g., "Disconnected: Sony WH-1000XM4")
3. Devices panel shows disconnected device with "Disconnected" status briefly before removal
4. Alert follows same acknowledgment pattern as threshold alerts
5. Reconnection clears the disconnect alert automatically

## Tasks / Subtasks

- [x] Integrate disconnect detection with alerts (AC: 1, 2)
  - [ ] Get disconnected devices from DevicesCollector.get_disconnected_devices()
  - [ ] Create DEVICE_DISCONNECT alert for each disconnected device
  - [ ] Include device name in alert message
- [x] Update alert engine for disconnect events (AC: 1, 4)
  - [ ] Add handle_disconnections(names: list[str]) method
  - [ ] Create alerts for each disconnected device
  - [ ] Alerts follow same lifecycle as threshold alerts
- [x] Show "Disconnected" status briefly (AC: 3)
  - [ ] When device disconnects, keep in list briefly with "Disconnected" status
  - [ ] Visual indicator (grayed out, strikethrough, or label)
  - [ ] Remove after 5-10 seconds or next refresh cycle
- [x] Auto-clear on reconnection (AC: 5)
  - [ ] Track disconnected device addresses
  - [ ] When device reconnects, clear the disconnect alert
  - [ ] Update alert engine with reconnected device info
- [x] Integrate with refresh loop
  - [ ] Call devices_collector.get_disconnected_devices()
  - [ ] Pass to alert_engine.handle_disconnections()
  - [ ] Update alert display

## Dev Notes

**Disconnect Detection Flow:**
```
1. DevicesCollector maintains known device set
2. On each collect_bluetooth() call:
   - Compare current devices to known devices
   - Devices in known but not current = disconnected
   - Store disconnected names
3. get_disconnected_devices() returns and clears the list
4. AlertEngine creates DEVICE_DISCONNECT alerts
```

**Alert Engine Extension:**
```python
class AlertEngine:
    def handle_disconnections(self, device_names: list[str]) -> None:
        """Handle Bluetooth device disconnections.

        Args:
            device_names: Names of devices that disconnected.
        """
        now = datetime.now()
        for name in device_names:
            # Use a composite key to allow multiple disconnect alerts
            alert_key = f"disconnect_{name}"
            self._alerts[alert_key] = Alert(
                alert_type=AlertType.DEVICE_DISCONNECT,
                message=f"Disconnected: {name}",
                triggered_at=now,
                source_panel="devices",
            )

    def handle_reconnection(self, device_name: str) -> None:
        """Clear disconnect alert when device reconnects.

        Args:
            device_name: Name of reconnected device.
        """
        alert_key = f"disconnect_{device_name}"
        if alert_key in self._alerts:
            del self._alerts[alert_key]
```

**Devices Panel "Disconnected" Status:**
```python
class DevicesPanel(BasePanel):
    def __init__(self):
        super().__init__()
        self._recently_disconnected: dict[str, datetime] = {}
        self._disconnect_display_duration = timedelta(seconds=5)

    def mark_disconnected(self, device_names: list[str]) -> None:
        """Mark devices as recently disconnected."""
        now = datetime.now()
        for name in device_names:
            self._recently_disconnected[name] = now

    def update(self, battery, devices, history=None) -> None:
        # ... existing update logic ...

        # Clean up old disconnections
        now = datetime.now()
        self._recently_disconnected = {
            name: time for name, time in self._recently_disconnected.items()
            if now - time < self._disconnect_display_duration
        }

        # Render recently disconnected devices
        for name in self._recently_disconnected:
            self._render_disconnected_device(name)

    def _render_disconnected_device(self, name: str) -> None:
        """Render a recently disconnected device."""
        # Grayed out with "Disconnected" label
        # e.g., "ğŸ§ Sony WH-1000XM4  [Disconnected]"
```

**Visual Representation:**
```
â”Œâ”€ Devices â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â— â”€â”
â”‚ ğŸ”‹ Laptop Battery                 â”‚
â”‚ ...                               â”‚
â”‚                                   â”‚
â”‚ ğŸ“¶ Bluetooth Devices              â”‚
â”‚ ğŸ§ Sony WH-1000XM4    [Disconnected] â”‚  <- Grayed, about to disappear
â”‚ ğŸ–±ï¸ MX Master 3        [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 85% â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**App Integration:**
```python
def _refresh_data(self) -> None:
    # ... existing collection ...

    # Get Bluetooth devices
    bt_devices = self._devices_collector.collect_bluetooth()

    # Get disconnections
    disconnected = self._devices_collector.get_disconnected_devices()

    # Handle disconnections
    if disconnected:
        self._alert_engine.handle_disconnections(disconnected)
        devices_panel = self.query_one(DevicesPanel)
        devices_panel.mark_disconnected(disconnected)

    # Check for reconnections
    for device in bt_devices:
        self._alert_engine.handle_reconnection(device.name)

    # ... rest of refresh ...
```

**Reconnection Detection:**
```python
class DevicesCollector:
    def __init__(self):
        self._known_devices: dict[str, str] = {}  # address -> name
        self._disconnected: list[str] = []

    def collect_bluetooth(self) -> list[BluetoothDevice]:
        devices = self._enumerate_devices()

        current = {d.address: d.name for d in devices}

        # Find disconnections
        for addr, name in self._known_devices.items():
            if addr not in current:
                self._disconnected.append(name)

        # Find reconnections (return for alert clearing)
        reconnected = []
        for addr, name in current.items():
            if addr not in self._known_devices:
                # Could be new or reconnected - check name
                reconnected.append(name)

        self._known_devices = current
        return devices

    def get_reconnected_devices(self) -> list[str]:
        """Get names of devices that reconnected."""
        # This would need tracking of previously disconnected
        # Implementation depends on how we want to track
        pass
```

### Testing

**Test Location:** tests/unit/ and tests/integration/

**Testing Standards:**
- Framework: pytest 8.0.0
- Run with: `pytest tests/unit/data_sources/test_devices.py tests/integration/test_app.py`

**Test Cases:**
```python
def test_disconnect_creates_alert():
    """Test that disconnection creates an alert."""
    engine = AlertEngine()

    engine.handle_disconnections(["Sony WH-1000XM4"])

    alerts = engine.get_active_alerts()
    assert len(alerts) == 1
    assert alerts[0].alert_type == AlertType.DEVICE_DISCONNECT
    assert "Sony WH-1000XM4" in alerts[0].message

def test_reconnect_clears_alert():
    """Test that reconnection clears the disconnect alert."""
    engine = AlertEngine()
    engine.handle_disconnections(["Sony WH-1000XM4"])

    engine.handle_reconnection("Sony WH-1000XM4")

    alerts = engine.get_active_alerts()
    assert len(alerts) == 0

def test_collector_tracks_disconnections():
    """Test that collector detects device disconnections."""
    collector = DevicesCollector()

    # First call - device present
    collector._known_devices = {"AA:BB:CC:DD:EE:FF": "Sony WH-1000XM4"}

    # Mock enumerate to return empty
    collector._enumerate_devices = lambda: []
    collector.collect_bluetooth()

    disconnected = collector.get_disconnected_devices()
    assert "Sony WH-1000XM4" in disconnected

async def test_disconnect_shows_in_devices_panel():
    async with app.run_test() as pilot:
        panel = app.query_one(DevicesPanel)
        panel.mark_disconnected(["Sony WH-1000XM4"])
        panel.update(None, [])

        content = str(panel.render())
        assert "Sony WH-1000XM4" in content
        assert "Disconnected" in content
```

**Manual Verification:**
- Connect Bluetooth device (headphones, mouse)
- Verify device appears in Devices panel
- Turn off/disconnect Bluetooth device
- Verify alert appears
- Verify "Disconnected" status shows in panel
- Reconnect device
- Verify alert clears automatically

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_To be filled by QA agent_
