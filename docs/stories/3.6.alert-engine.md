# Story 3.6: Alert Threshold Engine

## Status

Draft

## Story

**As a** developer,
**I want** an alert engine that monitors metrics and triggers alerts when thresholds are exceeded,
**so that** the UI can display visual warnings.

## Acceptance Criteria

1. `alerts/engine.py` module exists with threshold monitoring logic
2. Hardcoded thresholds: battery <20%, CPU >80%, memory <10% free, disk <10% free
3. Engine checks all metrics on each refresh cycle (1Hz)
4. Engine maintains alert state: active alerts list with type, message, timestamp
5. Alerts are added when threshold crossed, remain until acknowledged
6. Engine provides API for UI to query active alerts and acknowledge them
7. Module includes unit tests with edge cases (exactly at threshold, recovery, etc.)

## Tasks / Subtasks

- [ ] Create Alert and AlertType data models (AC: 4)
  - [ ] Create src/monitor_dashboard/models/alerts.py
  - [ ] Define AlertType enum: LOW_BATTERY, HIGH_CPU, LOW_MEMORY, LOW_DISK, DEVICE_DISCONNECT
  - [ ] Define Alert dataclass with all fields
- [ ] Create AlertEngine class (AC: 1, 2, 3)
  - [ ] Create src/monitor_dashboard/alerts/__init__.py
  - [ ] Create src/monitor_dashboard/alerts/engine.py
  - [ ] Define threshold configuration (hardcoded for MVP)
  - [ ] Implement check_thresholds() method
- [ ] Implement threshold checking (AC: 2, 3)
  - [ ] Check battery percent < 20
  - [ ] Check CPU percent > 80
  - [ ] Check memory percent > 90 (i.e., <10% free)
  - [ ] Check disk percent > 90 (i.e., <10% free) for each disk
  - [ ] Return list of triggered alerts
- [ ] Manage alert state (AC: 4, 5)
  - [ ] Maintain list of active alerts
  - [ ] Track alert triggered_at timestamp
  - [ ] Track acknowledged status
  - [ ] Prevent duplicate alerts for same condition
- [ ] Implement acknowledgment API (AC: 6)
  - [ ] Add acknowledge_all() method
  - [ ] Add acknowledge_next() method (oldest first)
  - [ ] Acknowledged alerts don't re-trigger immediately
  - [ ] Implement hysteresis/cooldown logic
- [ ] Implement alert lifecycle (AC: 5, 6)
  - [ ] Alert states: triggered → acknowledged → cleared
  - [ ] Auto-clear when condition recovers (threshold OK)
  - [ ] Cooldown period after acknowledgment (prevent immediate re-trigger)
- [ ] Write unit tests (AC: 7)
  - [ ] Test threshold detection
  - [ ] Test exactly at threshold (boundary conditions)
  - [ ] Test recovery (threshold OK after being exceeded)
  - [ ] Test acknowledgment flow
  - [ ] Test hysteresis/cooldown

## Dev Notes

**Data Models:**
```python
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

class AlertType(Enum):
    LOW_BATTERY = "low_battery"
    HIGH_CPU = "high_cpu"
    LOW_MEMORY = "low_memory"
    LOW_DISK = "low_disk"
    DEVICE_DISCONNECT = "device_disconnect"

@dataclass
class Alert:
    """Active or acknowledged system alert."""
    alert_type: AlertType
    message: str
    triggered_at: datetime
    acknowledged: bool = False
    source_panel: str = ""
    cooldown_until: datetime | None = None
```

**Threshold Configuration (Hardcoded for MVP):**
```python
@dataclass(frozen=True)
class ThresholdConfig:
    battery_low: int = 20        # percent
    cpu_high: int = 80           # percent
    memory_high: int = 90        # percent used (i.e., <10% free)
    disk_high: int = 90          # percent used (i.e., <10% free)
    cooldown_seconds: int = 60   # Seconds before alert can re-trigger
```

**AlertEngine Implementation:**
```python
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

class AlertEngine:
    """Monitors metrics and manages alert lifecycle."""

    def __init__(self, config: ThresholdConfig | None = None):
        self._config = config or ThresholdConfig()
        self._alerts: dict[AlertType, Alert] = {}

    def check_thresholds(
        self,
        metrics: SystemMetrics | None,
        battery: BatteryStatus | None,
        disks: list[DiskInfo],
    ) -> list[Alert]:
        """Check all thresholds and update alert state.

        Args:
            metrics: System health metrics (CPU, memory)
            battery: Battery status
            disks: List of disk info

        Returns:
            List of currently active (unacknowledged) alerts.
        """
        now = datetime.now()

        # Check battery
        if battery and battery.is_present:
            self._check_threshold(
                AlertType.LOW_BATTERY,
                battery.percent < self._config.battery_low,
                f"Battery low: {battery.percent:.0f}%",
                "devices",
                now,
            )

        # Check CPU
        if metrics:
            self._check_threshold(
                AlertType.HIGH_CPU,
                metrics.cpu_percent > self._config.cpu_high,
                f"CPU high: {metrics.cpu_percent:.0f}%",
                "system-health",
                now,
            )

            # Check memory
            self._check_threshold(
                AlertType.LOW_MEMORY,
                metrics.memory_percent > self._config.memory_high,
                f"Memory low: {100 - metrics.memory_percent:.0f}% free",
                "system-health",
                now,
            )

        # Check disks
        for disk in disks:
            if disk.percent > self._config.disk_high:
                self._check_threshold(
                    AlertType.LOW_DISK,
                    True,
                    f"Disk {disk.mount_point} low: {100 - disk.percent:.0f}% free",
                    "storage",
                    now,
                )
                break  # Only one disk alert at a time

        return self.get_active_alerts()

    def _check_threshold(
        self,
        alert_type: AlertType,
        exceeded: bool,
        message: str,
        source_panel: str,
        now: datetime,
    ) -> None:
        """Check a single threshold and update alert state."""
        existing = self._alerts.get(alert_type)

        if exceeded:
            if existing is None:
                # New alert
                self._alerts[alert_type] = Alert(
                    alert_type=alert_type,
                    message=message,
                    triggered_at=now,
                    source_panel=source_panel,
                )
            elif existing.cooldown_until and now < existing.cooldown_until:
                # In cooldown period, don't re-trigger
                pass
            elif existing.acknowledged:
                # Was acknowledged, now re-triggering
                existing.acknowledged = False
                existing.triggered_at = now
                existing.message = message
        else:
            # Threshold OK - clear alert if exists
            if existing and not existing.acknowledged:
                del self._alerts[alert_type]
            elif existing and existing.acknowledged:
                # Acknowledged alert, threshold now OK - remove
                del self._alerts[alert_type]

    def get_active_alerts(self) -> list[Alert]:
        """Get currently active (unacknowledged) alerts."""
        return [a for a in self._alerts.values() if not a.acknowledged]

    def acknowledge_all(self) -> None:
        """Acknowledge all active alerts."""
        now = datetime.now()
        cooldown = timedelta(seconds=self._config.cooldown_seconds)
        for alert in self._alerts.values():
            if not alert.acknowledged:
                alert.acknowledged = True
                alert.cooldown_until = now + cooldown

    def acknowledge_next(self) -> Alert | None:
        """Acknowledge oldest unacknowledged alert."""
        now = datetime.now()
        cooldown = timedelta(seconds=self._config.cooldown_seconds)
        active = sorted(
            [a for a in self._alerts.values() if not a.acknowledged],
            key=lambda a: a.triggered_at
        )
        if active:
            active[0].acknowledged = True
            active[0].cooldown_until = now + cooldown
            return active[0]
        return None
```

**Alert State Machine:**
```
[No Alert] --threshold exceeded--> [Triggered]
[Triggered] --user acknowledges--> [Acknowledged + Cooldown]
[Triggered] --threshold OK--> [No Alert]
[Acknowledged + Cooldown] --threshold OK--> [No Alert]
[Acknowledged + Cooldown] --cooldown expires + threshold exceeded--> [Triggered]
```

### Testing

**Test Location:** tests/unit/

**Testing Standards:**
- Framework: pytest 8.0.0
- Run with: `pytest tests/unit/test_alert_engine.py`

**Test Patterns:**
```python
from datetime import datetime, timedelta

def test_engine_triggers_low_battery_alert():
    """Test low battery threshold detection."""
    engine = AlertEngine(ThresholdConfig(battery_low=20))
    battery = BatteryStatus(percent=15, state=BatteryState.DISCHARGING,
                           time_remaining=None, is_present=True)

    alerts = engine.check_thresholds(None, battery, [])

    assert len(alerts) == 1
    assert alerts[0].alert_type == AlertType.LOW_BATTERY

def test_engine_clears_alert_when_threshold_ok():
    """Test alert clears when threshold recovers."""
    engine = AlertEngine(ThresholdConfig(battery_low=20))

    # First: trigger alert
    battery_low = BatteryStatus(percent=15, ...)
    engine.check_thresholds(None, battery_low, [])

    # Then: threshold OK
    battery_ok = BatteryStatus(percent=50, ...)
    alerts = engine.check_thresholds(None, battery_ok, [])

    assert len(alerts) == 0

def test_engine_boundary_at_threshold():
    """Test behavior exactly at threshold boundary."""
    engine = AlertEngine(ThresholdConfig(battery_low=20))

    # Exactly at 20% - should NOT trigger (threshold is <20)
    battery = BatteryStatus(percent=20, ...)
    alerts = engine.check_thresholds(None, battery, [])

    assert len(alerts) == 0

    # At 19% - should trigger
    battery = BatteryStatus(percent=19, ...)
    alerts = engine.check_thresholds(None, battery, [])

    assert len(alerts) == 1

def test_acknowledge_prevents_immediate_retrigger():
    """Test cooldown after acknowledgment."""
    engine = AlertEngine(ThresholdConfig(battery_low=20, cooldown_seconds=60))
    battery = BatteryStatus(percent=15, ...)

    # Trigger
    engine.check_thresholds(None, battery, [])
    assert len(engine.get_active_alerts()) == 1

    # Acknowledge
    engine.acknowledge_all()
    assert len(engine.get_active_alerts()) == 0

    # Check again immediately - should not re-trigger (in cooldown)
    alerts = engine.check_thresholds(None, battery, [])
    assert len(alerts) == 0

def test_acknowledge_all():
    """Test acknowledging multiple alerts."""
    engine = AlertEngine()
    # Trigger multiple alerts
    metrics = SystemMetrics(cpu_percent=95, memory_percent=95, ...)
    battery = BatteryStatus(percent=10, ...)
    engine.check_thresholds(metrics, battery, [])

    assert len(engine.get_active_alerts()) == 3  # CPU, memory, battery

    engine.acknowledge_all()
    assert len(engine.get_active_alerts()) == 0
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 0.1 | Initial story creation | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_To be filled by QA agent_
